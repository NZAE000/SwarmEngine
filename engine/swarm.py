import math
from engine.agent import Agent
from pathlib import Path
import random as rnd
import sys

sys.path.append(str(Path(__file__).parent.parent))
from util.minmaxMov import getMinMax
from util.median_minmaxMov import *

##############################################################################################################
# SWARM ALGORITHM ENGINE
##############################################################################################################
class Swarm():
  def __init__(self, algorithm_name, problem, iterations, nAgents):

    self.id = algorithm_name + "-" + problem.name

    # Params base
    self.maxIter     = iterations
    self.currentIter = 1
    self.nAgents     = nAgents

    # Problem
    self.problem = problem

    # Agents
    self.swarm = []                               # Agent storage
    self.gBest = Agent(self.problem.dimension)    # Global Best

    self.times_wrong = 0                          # No feasible counter 
    self.normalize   = self.sigmoidNormalize      # Default normalization

    # Constants needed for the problem !!
    self.minmax_movs      = []
    self.minmax_movs_disp = []
    self.normalized_consts = []

# Loggers and writers ######################################################
    # File paths
    self.path_gbestLog     = str(Path(__file__).parent.parent) + "/swarm_logs/gbest_log" + self.id + ".txt"
    self.path_agentLog     = str(Path(__file__).parent.parent) + "/swarm_logs/agent_log" + self.id + ".txt"
    self.path_movLog       = str(Path(__file__).parent.parent) + "/swarm_logs/mov_log"   + self.id + ".txt"
    self.path_gbestData    = str(Path(__file__).parent.parent) + "/data/all_gbest"       + self.id + ".txt"
    self.path_minmaxData   = str(Path(__file__).parent.parent) + "/data/minmax_mov"      + self.id + ".txt"
    self.path_constantData = str(Path(__file__).parent.parent) + "/data/constant_sigm"   + self.id + ".txt"

    # File loggers #########################################################
    self.gbestLogger = open(self.path_gbestLog, "w")
    self.agentLogger = open(self.path_agentLog, "w")
    self.movLogger   = open(self.path_movLog,   "w")

    # File data-writers
    self.gBestWriter    = open(self.path_gbestData,    "w")
    self.minmaxWriter   = open(self.path_minmaxData,   "w")
    self.constantWriter = open(self.path_constantData, "w")
    ########################################################################


# HELPER METHODS ###########################################################
  def isFeasible(self, agent):
    return self.problem.isFeasible(agent.position)
  
  def isBetterThanGBest(self, agent):
    return self.problem.isFirstBetterSecond(agent.pBest, self.gBest.pBest)

  def isBetterThanPBest(self, agent):
    return self.problem.isFirstBetterSecond(agent.position, agent.pBest)
  
  # RANDOM normalize: give random from domain of xi (index) variable
  def randNormalize(self, x, index):
    domain     = self.problem.domain(index)
    rand_index = rnd.randint(0, len(domain)-1)
    return domain[rand_index] # Get random and return

  # SIGMOID Normalize: normalize variable on some index dimension
  def sigmoidNormalize(self, x, index):
    discrete_domain = self.problem.domain(index)
    size_domain     = len(discrete_domain)

    # Binary domain
    if size_domain == 2:
      sigmoid = 1 / (1 + math.pow(math.e, -(x))) # Sigmoid [0, 1]
      return self.problem.maxDomain(index) if sigmoid > rnd.random() else self.problem.minDomain(index)
    
    # More than 2 domain values
    print("index: ", index)
    print("no trans: ", x)
    x_trans         = self.transform(x, index)
    print("trans: ", x_trans)
    uniform_val     = 1 / size_domain
    constant        = self.normalized_consts[index]
    sigmoid         = 1 / (1 + math.pow(math.e, -constant*x_trans)) # Sigmoid [0, 1]
    print("mmm")
    sum    = uniform_val
    chosen = 0

    for discrete in discrete_domain:
      if (sigmoid <= sum):
        chosen = discrete
        break
      sum += uniform_val
    
    #print("sigm: ", sigmoid, " sum: ", sum, " chosen: ", chosen, "\n")

    return chosen

  def transform(self, x, index):
    # If movement generated by pso(f.exp) was 60.0456 => Transform(rule of 3):
    #
    #                  -52.450689271945095  -   132.0017963588519     <- original range, where x is located
    #                  -92.22624281539849   -   92.22624281539849     <- displaced range, so transform x for this range
    #                  
    #                                     -52 |-----------------------------------------------| 132
    #                  -92 |-----------------------------------------------| 92
    #
    minmax      = self.minmax_movs[index]             # [-52.450689271945095, 132.0017963588519], f. exm
    minmax_disp = self.minmax_movs_disp[index]        # [-92.22624281539849, 92.22624281539849], f. exm
    #total_values   = minmax[1] - minmax[0]           # 132.0017963588519 - (-52.450689271945095) = 184.45.. => 100%
    values_up_to_x = x - minmax[0]                    # 60.0456 - (-52.450689271945095)           = 112.49..  => x%
    x_trans        = minmax_disp[0] + values_up_to_x  # => -92.22624281539849 + 112.49.. = 20.2638.. = x transformed.

    return x_trans
############################################################################

# PREPARE CONSTANTS TO HELP SOLVE PROBLEM
  def prepare(self, n_exec=30):
    self.normalize = self.randNormalize # Set random normalize to find min and max movements for each variable (dimensions).
    self.initWriters()
   
    for _ in range(n_exec): # Write min and max movement for each varable(position) of problem.
      self.solve()
      self.writeMinMaxData(getMinMax(self.path_movLog, self.problem.dimension))
    
    # Calculate min and max movement(median) for each varable(position) of problem of all excecutions.
    self.minmax_movs       = getMedianMinMax(self.path_minmaxData)
    self.minmax_movs_disp  = displacement(self.minmax_movs)      # Apply displacement
    self.normalized_consts = getConstants(self.minmax_movs_disp) # Set constants to use in the normalize
    self.writeConstantData()
    
    self.normalize = self.sigmoidNormalize # Restore
    self.closeWriters()

# RUNNER
  def solve(self, n_exec=1):
    self.gBestWriter = open(self.path_gbestData, "w")

    for _ in range(n_exec): # Executions
      self.init()
      self.evolve()
      self.writeGBest()
    
    self.closeLoggers()
    self.gBestWriter.close()

# INITIALIZE SWARM #########################################################
  def init(self):
    self.initLoggers()
    self.initAgents()
    self.initGlobalBest()
    self.currentIter = 1
    self.times_wrong = 0

# INITIALIZE LOGGERS
  def initLoggers(self):
    self.closeLoggers()
    self.gbestLogger = open(self.path_gbestLog, "w")
    self.agentLogger = open(self.path_agentLog, "w")
    self.movLogger   = open(self.path_movLog,   "w")

# CLOSE LOGGERS
  def closeLoggers(self):
    self.gbestLogger.close()
    self.agentLogger.close()
    self.movLogger.close()

# INIITALIZE AGENTS
  def initAgents(self):
    self.swarm.clear() # Clear agent storage

    for _ in range(self.nAgents):
      agent = Agent(self.problem.dimension) # Agents instantiated with problem dimension
      while True:
        agent.assign(self.problem.anySolution())
        if self.isFeasible(agent):
          break
      self.swarm.append(agent)
    
    # Initiaization in the specific algorithm.
    self.initAllAgents()

# INITIALIZE GLOBAL BEST
  def initGlobalBest(self):
    self.initGBest()  # Initialize global best
    self.findGBest()  # Find global best

    #self.bestToConsole()

# Run optimization
  def evolve(self):
    while self.currentIter <= self.maxIter:
      self.updateParams()             # Update params
      self.updateAgents()             # Update all agents
      self.findGBest()                # Find global best
      self.agentsToFile()             # Log all agents
      self.bestToFile()               # Log global best
      self.currentIter += 1           # Advance

# Update all agents (by default. Others algorithms can be override this method).
  def updateAgents(self):
    #print("\niter: ", self.currentIter)
    for agent in self.swarm:
      #print("before => pos: ", agent.position, " best_pos: ", agent.pBest)
      self.updateOne(agent)
      #print("after  => pos: ", agent.position, " best_pos: ", agent.pBest, "\n")

# Update one agent
  def updateOne(self, agent):
    backupAgent = Agent(self.problem.dimension)
    motion_log = []

    # Move until feasible
    while True:
      backupAgent.copy(agent)
      self.moveAgent(backupAgent, motion_log)
      self.motionTofile(motion_log)      # Log movement
      motion_log.clear()

      if self.isFeasible(backupAgent):
        #print("feasible")
        break
      else:
        #print("no feasible")
        self.times_wrong += 1

    # Update pBest
    if self.isBetterThanPBest(backupAgent):
      backupAgent.updatePBest()

    # Update agent
    agent.copy(backupAgent)

# Agent log
  def agentLog(self, agent):
    return self.problem.evalLog(agent.pBest)

# Log global best to file
  def bestToFile(self):
    self.gbestLogger.write(f"{self.agentLog(self.gBest)}\n")

# Log global best to console
  def bestToConsole(self):
    print(f"{self.agentLog(self.gBest)}")

# Log all agent to file
  def agentsToFile(self):
    self.agentLogger.write(f"Iter {self.currentIter}\n")
    for agent in self.swarm:
      self.agentTofile(agent)

# Log agent to file
  def agentTofile(self, agent):
    self.agentLogger.write(f"\tpos: {agent.position} - best_pos: {self.agentLog(agent)}\n")

# Log motion to file
  def motionTofile(self, motion):
    self.movLogger.write(f"{motion}\n")

# Global best writer
  def writeGBest(self):
    avgWrongPerAgent = self.times_wrong / (self.maxIter * self.nAgents)
    self.gBestWriter.write(f"{f"{self.agentLog(self.gBest)}-{avgWrongPerAgent}\n"}")
    
# Min Max data writer
  def writeMinMaxData(self, minmax):
    self.minmaxWriter.write(f"{minmax}\n")

# Constant data writer
  def writeConstantData(self):
    self.constantWriter.write(f"{self.minmax_movs}\n")
    self.constantWriter.write(f"{self.minmax_movs_disp}\n")
    self.constantWriter.write(f"{self.normalized_consts}\n")

# Initialize writers
  def initWriters(self):
    self.closeWriters()
    self.minmaxWriter   = open(self.path_minmaxData, "w")
    self.constantWriter = open(self.path_constantData, "w")

# Close writers
  def closeWriters(self):
    self.minmaxWriter.close()
    self.constantWriter.close()

## INTERFACE ###############################

# INIT ALL AGENTS.
  def initAllAgents(self):
    pass

# UPDATE PARAMETERS.
  def updateParams(self):
    pass

# MOVE: the implementer should append the pos+perturbance for each dimension to 'motion_log'.
  def moveAgent(self, motion_log):
    pass

# SEARCH G (Default).
  def findGBest(self):
    for i in range(self.nAgents):
      if self.isBetterThanGBest(self.swarm[i]):
        self.gBest.copy(self.swarm[i]) # Update GBest.
        
# Reset global best (default)
  def initGBest(self):
    self.gBest.copy(self.swarm[0]) # Copy first feasible agent.
